/*
 * Copyright (c) 2005-2011 Clark & Parsia, LLC. <http://www.clarkparsia.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.complexible.common.base;

import java.util.EnumMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

/**
 * 
 * @author  Evren Sirin
 * @since   2.0
 * @version 2.0
 */
public final class Durations {	
	private static final Map<String, TimeUnit> UNITS = ImmutableMap.<String, TimeUnit> builder()
//	                .put("ns", TimeUnit.NANOSECONDS)
	                .put("ms", TimeUnit.MILLISECONDS)
	                .put("s", TimeUnit.SECONDS)
	                .put("m", TimeUnit.MINUTES)
	                .put("h", TimeUnit.HOURS)
	                .put("d", TimeUnit.DAYS)
	                .build();

	// enum map is guaranteed to provide a consistent iteration order from smaller time units to largers
	private static final EnumMap<TimeUnit, String> ABBR = Maps.newEnumMap(HashBiMap.create(UNITS).inverse());

	private Durations() {
        throw new AssertionError();
	}

	/**
	 * Returns a readable representation of the given milliseconds duration. This function is equivalent to
	 * <code>readable(theMilliseconds, TimeUnit.MILLISECONDS)</code>. 
	 * 
	 * @see #readable(long, TimeUnit)
	 */
	public static String readable(long theMilliseconds) {
		return readable(theMilliseconds, TimeUnit.MILLISECONDS);
	}
	
	/**
	 * Returns a readable representation of the given duration. The readable duration is a positive integer followed by
	 * either letter 'h' (for hours), letter 'm' (for minutes), letter 's' (for seconds), or letters 'ms' (for
	 * milliseconds). The function chooses the most appropriate unit to use in the output without losing precision.
	 * It is the case that for every integer <code>N</code> and {@link TimeUnit} <code>T</code>, we will have
	 * <code>parse(readable(N, T)) == T.toMillis(N)</code>.
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><code>readable(1, TimeUnit.SECONDS)</code> returns <code>"1s"</code></li>
	 * <li><code>readable(60, TimeUnit.SECONDS)</code> returns <code>"1m"</code></li>
	 * <li><code>readable(80, TimeUnit.SECONDS)</code> returns <code>"80s"</code></li>
	 * <li><code>readable(12000, TimeUnit.SECONDS)</code> returns <code>"12m"</code></li>
	 * </ul>
	 * 
	 * @param theDuration duration value
	 * @param theUnit time unit for the input duration value
	 * @return readable representation of the given duration
	 */
	public static String readable(long theDuration, TimeUnit theUnit) {
		// special case for 0
		if (theDuration == 0) {
			return "0ms";
		}
		
		Iterator<Entry<TimeUnit,String>> aAbbrs = ABBR.entrySet().iterator();
		
		String aResult = null;
		boolean aFound = false;
		while (aAbbrs.hasNext()) {
			Entry<TimeUnit,String> aEntry = aAbbrs.next();
			if (!aFound) {
				if (aEntry.getKey().equals(theUnit)) {
					aFound = true;
					aResult = theDuration + aEntry.getValue();
				}
			}
			else {
				TimeUnit aConvertUnit = aEntry.getKey();
				long aConverted = aConvertUnit.convert(theDuration, theUnit);
				if (theUnit.convert(aConverted, aConvertUnit) == theDuration) {
					aResult = aConverted + aEntry.getValue();
				}
				else {
					break;
				}
			}
		}
		
		return aResult;
	}

	/**
	 * Parses the given readable representation of the duration into a milliseconds duration. This function
	 * is equivalent to <code>parse(theDuration, TimeUnit.MILLISECONDS)</code>.
	 * 
	 * @throws IllegalArgumentException
	 *             if the string representation is not a valid duration
	 */
	public static long parse(String theDuration) throws IllegalArgumentException {
		return parse(theDuration, TimeUnit.MILLISECONDS);
	}
	
	/**
	 * Parses the given readable representation of the duration into a duration value expressed in the requested time
	 * unit. The valid string representations are the ones that are generated by the {@link #readable(long, TimeUnit)}
	 * function. If the requested time unit is coarser than the duration represented by the string the result will lose
	 * precisions. For example, <code>parse("50s", TimeUnit.MINUTES)</code> would return <code>0</code>.
	 * 
	 * @param theDuration
	 *            readable representation of a duration value
	 * @param theOutputUnit
	 *            the unit of the output value
	 * @return a duration value expressed in the requested time unit that is represented
	 * @throws IllegalArgumentException
	 *             if the string representation is not a valid duration
	 */
	public static long parse(String theDuration, TimeUnit theOutputUnit) {
		String[] aSplit = splitDuration(theDuration);
		long aVal = parseDuration(aSplit[0]);
		TimeUnit aUnit = parseTimeUnit(aSplit[1]);
		return theOutputUnit.convert(aVal, aUnit);
	}

	private static String[] splitDuration(String theStr) {
		String theTrimmedStr = theStr.trim();

		if (theTrimmedStr.length() < 2) {
			throw new IllegalArgumentException("Invalid duration: " + theStr);
		}

		int aSplit = theTrimmedStr.length() - 2;

		if (Character.isDigit(theStr.charAt(aSplit))) {
			aSplit++;
		}

		return new String[] { theTrimmedStr.substring(0, aSplit), theTrimmedStr.substring(aSplit) };
	}	
	
	private static TimeUnit parseTimeUnit(String theStr) {
		TimeUnit aUnit = UNITS.get(theStr.toLowerCase());
		if (aUnit == null) {
			throw new IllegalArgumentException("Invalid time unit: " + theStr);
		}
		return aUnit;
	}

	private static int parseDuration(String theStr) {
		int aVal = Integer.parseInt(theStr);
		if (aVal < 0) {
			throw new IllegalArgumentException("Invalid duration: " + theStr);
		}
		return aVal;
	}
}
